{"version":3,"file":"index.js","sources":["../src/parse-path.js","../src/path2d-polyfill.js","../src/index.js"],"sourcesContent":["const ARG_LENGTH = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0,\n};\n\nconst SEGMENT_PATTERN = /([astvzqmhlc])([^astvzqmhlc]*)/ig;\n\nconst NUMBER = /-?[0-9]*\\.?[0-9]+(?:e[-+]?\\d+)?/ig;\n\nfunction parseValues(args) {\n  const numbers = args.match(NUMBER);\n  return numbers ? numbers.map(Number) : [];\n}\n\n/**\n * parse an svg path data string. Generates an Array\n * of commands where each command is an Array of the\n * form `[command, arg1, arg2, ...]`\n *\n * https://www.w3.org/TR/SVG/paths.html#PathDataGeneralInformation\n * @ignore\n *\n * @param {string} path\n * @returns {array}\n */\nfunction parse(path) {\n  const data = [];\n  const p = String(path).trim();\n\n  // A path data segment (if there is one) must begin with a \"moveto\" command\n  if (p[0] !== 'M' && p[0] !== 'm') {\n    return data;\n  }\n\n  p.replace(SEGMENT_PATTERN, (_, command, args) => {\n    let type = command.toLowerCase();\n    let theArgs = parseValues(args);\n    let theCommand = command;\n    // overloaded moveTo\n    if (type === 'm' && theArgs.length > 2) {\n      data.push([theCommand].concat(theArgs.splice(0, 2)));\n      type = 'l';\n      theCommand = theCommand === 'm' ? 'l' : 'L';\n    }\n\n    // Ignore invalid commands\n    if (theArgs.length < ARG_LENGTH[type]) {\n      return '';\n    }\n\n    data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type])));\n\n    // The command letter can be eliminated on subsequent commands if the\n    // same command is used multiple times in a row (e.g., you can drop the\n    // second \"L\" in \"M 100 200 L 200 100 L -100 -200\" and use\n    // \"M 100 200 L 200 100 -100 -200\" instead).\n    while (theArgs.length >= ARG_LENGTH[type] && theArgs.length && ARG_LENGTH[type]) {\n      data.push([theCommand].concat(theArgs.splice(0, ARG_LENGTH[type])));\n    }\n\n    return '';\n  });\n  return data;\n}\n\nmodule.exports = parse;\n","const parsePath = require('./parse-path');\n\n/**\n * Work around for https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8438884/\n * @ignore\n */\nfunction supportsSvgPathArgument(window) {\n  const canvas = window.document.createElement('canvas');\n  const g = canvas.getContext('2d');\n  const p = new window.Path2D('M0 0 L1 1');\n  g.strokeStyle = 'red';\n  g.lineWidth = 1;\n  g.stroke(p);\n  const imgData = g.getImageData(0, 0, 1, 1);\n  return imgData.data[0] === 255; // Check if pixel is red\n}\n\nfunction rotatePoint(point, angle) {\n  const nx = (point.x * Math.cos(angle)) - (point.y * Math.sin(angle));\n  const ny = (point.y * Math.cos(angle)) + (point.x * Math.sin(angle));\n  point.x = nx;\n  point.y = ny;\n}\n\nfunction translatePoint(point, dx, dy) {\n  point.x += dx;\n  point.y += dy;\n}\n\nfunction scalePoint(point, s) {\n  point.x *= s;\n  point.y *= s;\n}\n\nfunction polyFillPath2D(window) {\n  if (typeof window === 'undefined' || !window.CanvasRenderingContext2D) {\n    return;\n  }\n  if (window.Path2D && supportsSvgPathArgument(window)) {\n    return;\n  }\n\n  /**\n     * Crates a Path2D polyfill object\n     * @constructor\n     * @ignore\n     * @param {String} path\n     */\n  class Path2D {\n    constructor(path) {\n      this.segments = [];\n      if (path && path instanceof Path2D) {\n        this.segments.push(...path.segments);\n      } else if (path) {\n        this.segments = parsePath(path);\n      }\n    }\n\n    addPath(path) {\n      if (path && path instanceof Path2D) {\n        this.segments.push(...path.segments);\n      }\n    }\n\n    moveTo(x, y) {\n      this.segments.push(['M', x, y]);\n    }\n\n    lineTo(x, y) {\n      this.segments.push(['L', x, y]);\n    }\n\n    arc(x, y, r, start, end, ccw) {\n      this.segments.push(['AC', x, y, r, start, end, !!ccw]);\n    }\n\n    arcTo(x1, y1, x2, y2, r) {\n      this.segments.push(['AT', x1, y1, x2, y2, r]);\n    }\n\n    ellipse(x, y, rx, ry, angle, start, end, ccw) {\n      this.segments.push(['E', x, y, rx, ry, angle, start, end, !!ccw]);\n    }\n\n    closePath() {\n      this.segments.push(['Z']);\n    }\n\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n      this.segments.push(['C', cp1x, cp1y, cp2x, cp2y, x, y]);\n    }\n\n    quadraticCurveTo(cpx, cpy, x, y) {\n      this.segments.push(['Q', cpx, cpy, x, y]);\n    }\n\n    rect(x, y, width, height) {\n      this.segments.push(['R', x, y, width, height]);\n    }\n  }\n\n  const cFill = window.CanvasRenderingContext2D.prototype.fill;\n  const cStroke = window.CanvasRenderingContext2D.prototype.stroke;\n\n  function buildPath(canvas, segments) {\n    let endAngle;\n    let startAngle;\n    let largeArcFlag;\n    let sweepFlag;\n    let endPoint;\n    let midPoint;\n    let angle;\n    let lambda;\n    let t1;\n    let t2;\n    let x;\n    let x1;\n    let y;\n    let y1;\n    let r;\n    let rx;\n    let ry;\n    let w;\n    let h;\n    let pathType;\n    let centerPoint;\n    let cpx;\n    let cpy;\n    let qcpx;\n    let qcpy;\n    let ccw;\n    let startPoint = { x: 0, y: 0 };\n    const currentPoint = { x: 0, y: 0 };\n\n    canvas.beginPath();\n    for (let i = 0; i < segments.length; ++i) {\n      const s = segments[i];\n      pathType = s[0];\n\n      // Reset control point if command is not cubic\n      if (pathType !== 'S' && pathType !== 's' && pathType !== 'C' && pathType !== 'c') {\n        cpx = null;\n        cpy = null;\n      }\n\n      if (pathType !== 'T' && pathType !== 't' && pathType !== 'Q' && pathType !== 'q') {\n        qcpx = null;\n        qcpy = null;\n      }\n\n      switch (pathType) {\n        case 'm':\n        case 'M':\n          if (pathType === 'm') {\n            x += s[1];\n            y += s[2];\n          } else {\n            x = s[1];\n            y = s[2];\n          }\n\n          if (pathType === 'M' || !startPoint) {\n            startPoint = { x, y };\n          }\n\n          canvas.moveTo(x, y);\n          break;\n        case 'l':\n          x += s[1];\n          y += s[2];\n          canvas.lineTo(x, y);\n          break;\n        case 'L':\n          x = s[1];\n          y = s[2];\n          canvas.lineTo(x, y);\n          break;\n        case 'H':\n          x = s[1];\n          canvas.lineTo(x, y);\n          break;\n        case 'h':\n          x += s[1];\n          canvas.lineTo(x, y);\n          break;\n        case 'V':\n          y = s[1];\n          canvas.lineTo(x, y);\n          break;\n        case 'v':\n          y += s[1];\n          canvas.lineTo(x, y);\n          break;\n        case 'a':\n        case 'A':\n          if (pathType === 'a') {\n            x += s[6];\n            y += s[7];\n          } else {\n            x = s[6];\n            y = s[7];\n          }\n\n          rx = s[1]; // rx\n          ry = s[2]; // ry\n          angle = (s[3] * Math.PI) / 180;\n          largeArcFlag = !!s[4];\n          sweepFlag = !!s[5];\n          endPoint = { x, y };\n\n          // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\n          midPoint = {\n            x: (currentPoint.x - endPoint.x) / 2,\n            y: (currentPoint.y - endPoint.y) / 2,\n          };\n          rotatePoint(midPoint, -angle);\n\n          // radius correction\n          lambda = ((midPoint.x * midPoint.x) / (rx * rx))\n                 + ((midPoint.y * midPoint.y) / (ry * ry));\n          if (lambda > 1) {\n            lambda = Math.sqrt(lambda);\n            rx *= lambda;\n            ry *= lambda;\n          }\n\n          centerPoint = {\n            x: (rx * midPoint.y) / ry,\n            y: -(ry * midPoint.x) / rx,\n          };\n          t1 = rx * rx * ry * ry;\n          t2 = (rx * rx * midPoint.y * midPoint.y)\n             + (ry * ry * midPoint.x * midPoint.x);\n          if (sweepFlag !== largeArcFlag) {\n            scalePoint(centerPoint, Math.sqrt((t1 - t2) / t2) || 0);\n          } else {\n            scalePoint(centerPoint, -Math.sqrt((t1 - t2) / t2) || 0);\n          }\n\n          startAngle = Math.atan2(\n            (midPoint.y - centerPoint.y) / ry,\n            (midPoint.x - centerPoint.x) / rx);\n          endAngle = Math.atan2(\n            -(midPoint.y + centerPoint.y) / ry,\n            -(midPoint.x + centerPoint.x) / rx);\n\n          rotatePoint(centerPoint, angle);\n          translatePoint(\n            centerPoint,\n            (endPoint.x + currentPoint.x) / 2,\n            (endPoint.y + currentPoint.y) / 2);\n\n          canvas.save();\n          canvas.translate(centerPoint.x, centerPoint.y);\n          canvas.rotate(angle);\n          canvas.scale(rx, ry);\n          canvas.arc(0, 0, 1, startAngle, endAngle, !sweepFlag);\n          canvas.restore();\n          break;\n        case 'C':\n          cpx = s[3]; // Last control point\n          cpy = s[4];\n          x = s[5];\n          y = s[6];\n          canvas.bezierCurveTo(s[1], s[2], cpx, cpy, x, y);\n          break;\n        case 'c':\n          canvas.bezierCurveTo(\n            s[1] + x,\n            s[2] + y,\n            s[3] + x,\n            s[4] + y,\n            s[5] + x,\n            s[6] + y);\n          cpx = s[3] + x; // Last control point\n          cpy = s[4] + y;\n          x += s[5];\n          y += s[6];\n          break;\n        case 'S':\n          if (cpx === null || cpx === null) {\n            cpx = x;\n            cpy = y;\n          }\n\n          canvas.bezierCurveTo(\n            (2 * x) - cpx,\n            (2 * y) - cpy,\n            s[1],\n            s[2],\n            s[3],\n            s[4]);\n          cpx = s[1]; // last control point\n          cpy = s[2];\n          x = s[3];\n          y = s[4];\n          break;\n        case 's':\n          if (cpx === null || cpx === null) {\n            cpx = x;\n            cpy = y;\n          }\n\n          canvas.bezierCurveTo(\n            (2 * x) - cpx,\n            (2 * y) - cpy,\n            s[1] + x,\n            s[2] + y,\n            s[3] + x,\n            s[4] + y);\n          cpx = s[1] + x; // last control point\n          cpy = s[2] + y;\n          x += s[3];\n          y += s[4];\n          break;\n        case 'Q':\n          qcpx = s[1]; // last control point\n          qcpy = s[2];\n          x = s[3];\n          y = s[4];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n        case 'q':\n          qcpx = s[1] + x; // last control point\n          qcpy = s[2] + y;\n          x += s[3];\n          y += s[4];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n        case 'T':\n          if (qcpx === null || qcpx === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          qcpx = (2 * x) - qcpx; // last control point\n          qcpy = (2 * y) - qcpy;\n          x = s[1];\n          y = s[2];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n        case 't':\n          if (qcpx === null || qcpx === null) {\n            qcpx = x;\n            qcpy = y;\n          }\n          qcpx = (2 * x) - qcpx; // last control point\n          qcpy = (2 * y) - qcpy;\n          x += s[1];\n          y += s[2];\n          canvas.quadraticCurveTo(qcpx, qcpy, x, y);\n          break;\n        case 'z':\n        case 'Z':\n          x = startPoint.x;\n          y = startPoint.y;\n          startPoint = undefined;\n          canvas.closePath();\n          break;\n        case 'AC': // arc\n          x = s[1];\n          y = s[2];\n          r = s[3];\n          startAngle = s[4];\n          endAngle = s[5];\n          ccw = s[6];\n          canvas.arc(x, y, r, startAngle, endAngle, ccw);\n          break;\n        case 'AT': // arcTo\n          x1 = s[1];\n          y1 = s[2];\n          x = s[3];\n          y = s[4];\n          r = s[5];\n          canvas.arcTo(x1, y1, x, y, r);\n          break;\n        case 'E': // ellipse\n          x = s[1];\n          y = s[2];\n          rx = s[3];\n          ry = s[4];\n          angle = s[5];\n          startAngle = s[6];\n          endAngle = s[7];\n          ccw = s[8];\n          canvas.save();\n          canvas.translate(x, y);\n          canvas.rotate(angle);\n          canvas.scale(rx, ry);\n          canvas.arc(0, 0, 1, startAngle, endAngle, ccw);\n          canvas.restore();\n          break;\n        case 'R': // rect\n          x = s[1];\n          y = s[2];\n          w = s[3];\n          h = s[4];\n          startPoint = { x, y };\n          canvas.rect(x, y, w, h);\n          break;\n        default:\n          // throw new Error(`${pathType} is not implemented`); ?\n      }\n\n      currentPoint.x = x;\n      currentPoint.y = y;\n    }\n  }\n\n  window.CanvasRenderingContext2D.prototype.fill = function fill(...args) {\n    let fillRule = 'nonzero';\n    if (args.length === 0 || (args.length === 1 && typeof args[0] === 'string')) {\n      cFill.apply(this, args);\n      return;\n    }\n    if (arguments.length === 2) {\n      fillRule = args[1];\n    }\n    const path = args[0];\n    buildPath(this, path.segments);\n    cFill.call(this, fillRule);\n  };\n\n  window.CanvasRenderingContext2D.prototype.stroke = function stroke(path) {\n    if (!path) {\n      cStroke.call(this);\n      return;\n    }\n    buildPath(this, path.segments);\n    cStroke.call(this);\n  };\n\n  window.Path2D = Path2D;\n}\n\nmodule.exports = polyFillPath2D;\n","const parsePath = require('./parse-path');\nconst path2dPolyfill = require('./path2d-polyfill');\n\nif (typeof window !== 'undefined') {\n  path2dPolyfill(window);\n}\n\nmodule.exports = {\n  path2dPolyfill,\n  parsePath,\n};\n"],"names":["ARG_LENGTH","a","c","h","l","m","q","s","t","v","z","SEGMENT_PATTERN","NUMBER","path","data","p","String","trim","replace","_","command","args","type","toLowerCase","theArgs","numbers","match","map","Number","parseValues","theCommand","length","push","concat","splice","rotatePoint","point","angle","nx","x","Math","cos","y","sin","ny","scalePoint","window","CanvasRenderingContext2D","Path2D","g","document","createElement","getContext","strokeStyle","lineWidth","stroke","getImageData","supportsSvgPathArgument","segments","parsePath","r","start","end","ccw","x1","y1","x2","y2","rx","ry","cp1x","cp1y","cp2x","cp2y","cpx","cpy","width","height","cFill","prototype","fill","cStroke","fillRule","apply","this","arguments","buildPath","call","canvas","endAngle","startAngle","largeArcFlag","sweepFlag","endPoint","midPoint","lambda","t1","t2","w","pathType","centerPoint","qcpx","qcpy","dx","dy","startPoint","currentPoint","beginPath","i","moveTo","lineTo","PI","sqrt","atan2","save","translate","rotate","scale","arc","restore","bezierCurveTo","quadraticCurveTo","undefined","closePath","arcTo","rect","path2dPolyfill"],"mappings":"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"}